/*!
 * @file
 * @brief LCD Methods for the Rx210 Dev kit
 * File originally generated by renesas
 *
 * Copyright (c) 2014 - General Electric - All rights reserved.
 */

#include <stdint.h>
#include "r_pdl_io_port.h"
#include "r_pdl_cmt.h"
#include "r_pdl_definitions.h"
#include "Lcd.h"

#define RS_PIN PDL_IO_PORT_J_1  // RS register select pin
#define E_PIN  PDL_IO_PORT_J_3  // Display enable pin
#define DATA_WR 1               // Data write/read definition
#define CTRL_WR 0               // Control write/read definition
#define NUMB_CHARS_PER_LINE 8   // Maximum characters per line of LCD display
#define MAXIMUM_LINES    2      // Number of lines on the LCD display
#define LCD_CLEAR        0x01   // Clear LCD display and home cursor
#define LCD_HOME_L1      0x80   // Move cursor to line 1
#define LCD_HOME_L2      0xC0   // Move cursor to line 2
#define CURSOR_MODE_DEC  0x04   // Cursor auto decrement after R/W
#define CURSOR_MODE_INC  0x06   // Cursor auto increment after R/W
#define FUNCTION_SET     0x28   // Setup, 4 bits,2 lines, 5X7
#define LCD_CURSOR_ON    0x0E   // Display ON with Cursor
#define LCD_CURSOR_OFF   0x0C   // Display ON with Cursor off
#define LCD_CURSOR_BLINK 0x0D   // Display on with blinking cursor
#define LCD_CURSOR_LEFT  0x10   // Move Cursor Left One Position
#define LCD_CURSOR_RIGHT 0x14   // Move Cursor Right One Position
#define LCD_DISPLAY_ON   0x04   // Enable LCD display
#define LCD_TWO_LINE     0x08   // Enable both LCD lines

static void LCD_nibble_write(uint8_t data_or_ctrl, uint8_t value)
{
   bool err = 1;

   // Set Register Select pin high for Data
   if(data_or_ctrl == DATA_WR)
   {
      // Set RS pin high
      err &= R_IO_PORT_Write(RS_PIN, 1);
   }
   else
   {
      // Set RS pin low
      err &= R_IO_PORT_Write(RS_PIN, 0);
   }

   //tsu1 delay
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 200E-9, PDL_NO_FUNC, 0);

   // EN enable chip (HIGH)
   err &= R_IO_PORT_Write(E_PIN, 1);

   // Output the data
   err &= R_IO_PORT_Write(PDL_IO_PORT_H, (uint8_t )(value));

   // tw delay
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 2000E-9, PDL_NO_FUNC, 0);

   // Latch data by dropping E
   err &= R_IO_PORT_Write(E_PIN, 0);

   /* th2 delay */
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 40E-9, PDL_NO_FUNC, 0);
   ;

   // tc delay
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 2000E-9, PDL_NO_FUNC, 0);

   while(!err)
      ;
}

void LCD_write(uint8_t data_or_ctrl, uint8_t value)
{
   // Write upper nibble first
   LCD_nibble_write(data_or_ctrl, (uint8_t)((value & 0xF0) >> 4));

   // Write lower nibble second
   LCD_nibble_write(data_or_ctrl, (uint8_t)(value & 0x0F));
}

void Lcd_Init(void)
{
   bool err = true;

   // Power Up Delay for the LCD Module
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 1000E-3, PDL_NO_FUNC, 0);

   // Display initializes in 8 bit mode - so send one write (seen as 8 bit to set to 4 bit mode.
   LCD_nibble_write(CTRL_WR, 0x03);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 50E-3, PDL_NO_FUNC, 0);
   LCD_nibble_write(CTRL_WR, 0x03);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 50E-3, PDL_NO_FUNC, 0);
   LCD_nibble_write(CTRL_WR, 0x03);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 50E-3, PDL_NO_FUNC, 0);

   LCD_nibble_write(CTRL_WR, 0x02);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 100E-6, PDL_NO_FUNC, 0);
   LCD_nibble_write(CTRL_WR, 0x02);
   LCD_nibble_write(CTRL_WR, (LCD_DISPLAY_ON | LCD_TWO_LINE));
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 100E-6, PDL_NO_FUNC, 0);

   // Display ON/OFF control
   LCD_write(CTRL_WR, LCD_CURSOR_OFF);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 100E-6, PDL_NO_FUNC, 0);

   // Display Clear
   LCD_write(CTRL_WR, LCD_CLEAR);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 25E-3, PDL_NO_FUNC, 0);

   // Entry Mode Set
   LCD_write(CTRL_WR, 0x06);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 100E-6, PDL_NO_FUNC, 0);

   // Home the cursor
   LCD_write(CTRL_WR, LCD_HOME_L1);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 20E-3, PDL_NO_FUNC, 0);

   while(!err)
      ;
}

void Lcd_Clear(void)
{
   bool err = 1;

   LCD_write(CTRL_WR, LCD_CLEAR);
   err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 20E-3, PDL_NO_FUNC, 0);

   while(!err)
      ;
}

void Lcd_Display(uint8_t position, const uint8_t * string)
{
   static uint8_t next_pos = 0xFF;
   bool err = 1;

   // Set line position if needed. We don't want to if we don't need
   // to because LCD control operations take longer than LCD data
   // operations.
   if(next_pos != position)
   {
      if(position < LCD_LINE2_START_POS)
      {
         LCD_write(CTRL_WR, ((uint8_t)(LCD_HOME_L1 + position)));
      }
      else
      {
         LCD_write(CTRL_WR, ((uint8_t)((LCD_HOME_L2 + position) - LCD_LINE2_START_POS)));
      }

      // Create one-shot delay after sending the command to the LCD
      err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 100E-6, PDL_NO_FUNC, 0);

      // Set position index to known value
      next_pos = position;
   }

   do
   {
      LCD_write(DATA_WR, *string++);

      // Create oneshot delay after sending the display data to the LCD
      err &= R_CMT_CreateOneShot(2, PDL_CMT_PERIOD, 100E-6, PDL_NO_FUNC, 0);

      next_pos++;
   }

   while(*string);

   while(!err)
      ;
}
